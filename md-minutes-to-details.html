<doctype html>
<html>
   <head>
      <meta charset='utf-8'>
   </head>
   <body>
      Markdown:
      <br>
      <textarea id='e_in' style='width: 100%; height: 50vh;'>
&lt;!-- Output copied to clipboard! --&gt;


# WGSL 2021-00-00 Minutes

## H2

### Example 1

* lorem


### [Example 2](example.com)

* ipsum

### Example [5](example.com/5) (stuff)

* dolor


## H2 Example [3](example.com/3)

* sit amet

</textarea>
      <hr>
      Minute details: <button id='e_extract'>Extract</button>
      <div id='e_out'></div>
      <script>
'use strict';

function count_char_repeats(str, c) {
   let i = 0;
   while (str[i] == c) {
      i += 1;
   }
   return i;
}
{
   if (count_char_repeats('### hi', '#') != 3) throw 3;
}

function MdSection(title) {
   this.title = title;
   this.h_level = count_char_repeats(title || '', '#');
   this.children = [];

   this.add_child = child => {
      child.parent = this;
      this.children.push(child);
   };
}

function md_to_tree(text) {
   const lines = text.split('\n');
   const root = new MdSection(null);
   let cur_sec = root;
   while (lines.length) {
      const line = lines.shift();
      const h_level = count_char_repeats(line, '#');
      if (!h_level) {
         cur_sec.children.push(line);
         continue;
      }
      const new_sec = new MdSection(line);

      const parent_h_level = new_sec.h_level - 1;
      while (cur_sec.h_level > parent_h_level) {
         cur_sec = cur_sec.parent;
      }
      while (cur_sec.h_level < parent_h_level) {
         const dummy = new MdSection('#'.repeat(cur_sec.h_level + 1));
         dummy.title = undefined;
         cur_sec.add_child(dummy);
         cur_sec = dummy;
      }

      cur_sec.add_child(new_sec);
      cur_sec = new_sec;
   }
   return root;
}

function* range(n) {
   for (let i = 0; i < n; i++) {
      yield i;
   }
}

function trimPrefix(str, prefix) {
   if (str.startsWith(prefix)) {
      str = str.slice(prefix.length);
   }
   return str;
}
function withoutPrefix(str, prefix) {
   const ret = trimPrefix(str, prefix);
   if (ret == str) throw {str, prefix};
   return ret;
}

const RE_DATE = /\d\d\d\d-\d\d-\d\d/;
function find_date(str) {
   const match = str.match(RE_DATE) || [];
   return match;
}
if (find_date('# WGSL 2021-04-13 Minutes') != '2021-04-13') throw 'find_date';

function to_github_url_slug(text) {
   let parts = text.split(/ +/);
   parts = parts.map(s => {
      s = s.toLowerCase();
      s = [].filter.call(s, c => c.match(/[0-9A-Za-z-_()]/));
      s = s.join('');
      return s;
   });
   return parts.join('-');
}
function to_github_anchor_slug(text) {
   let ret = to_github_url_slug(text);
   ret = ret.replaceAll(/[()]/g, '');
   return ret;
}

{
   const title = '[wgsl] Proposal: Remove pointer out parameters from modf, frexp 路 Issue #1480 路 gpuweb/gpuweb';
   const expected = 'wgsl-proposal-remove-pointer-out-parameters-from-modf-frexp--issue-1480--gpuwebgpuweb';
   const was = to_github_anchor_slug(title);
   if (was != expected) throw was;
}
{
   const title = 'Triage the issues without milestones (timebox 15m).';
   const expected = 'triage-the-issues-without-milestones-timebox-15m';
   const was = to_github_anchor_slug(title);
   if (was != expected) throw was;
}

const RE_URL = /\[(.*)\]\((.*?)\)/g;

function section_desc(h3_section) {
   const section_title = withoutPrefix(h3_section.title, '### ');
   const found = Array.from(section_title.matchAll(RE_URL));
   const issue_url = (found[0] || [])[2];
   const title_text = section_title.replaceAll(RE_URL, '$1');
   const slug = to_github_anchor_slug(title_text);

   return {
      issue_url,
      slug,
      text: h3_section.children.join('\n'),
   };
}

{
   const text = `\


*   DM: Do we want to spend innovation budget on anonymous structs here?
*   BC: Previously there were concerns about having to have a named struct to return here, but now with type inference, we could return anonymous structs here. Not necessarily proposing userland anonymous structs, and if we decided to name them in the future, we could name them.
*   DM: Some complexity, new types for these builtins.`;
   const h3_section = {
      title: '### [[wgsl] Proposal: Remove pointer out parameters from modf, frexp 路 Issue #1480 路 gpuweb/gpuweb](https://github.com/gpuweb/gpuweb/issues/1480)',
      h_level: 3,
      children: text.split('\n'),
   };
   const expected = {
      issue_url: 'https://github.com/gpuweb/gpuweb/issues/1480',
      slug: 'wgsl-proposal-remove-pointer-out-parameters-from-modf-frexp--issue-1480--gpuwebgpuweb',
      text: text,
   };
   const was = section_desc(h3_section);
   if (JSON.stringify(expected) != JSON.stringify(was)) throw was;
}

function make_details(date, wiki_url, desc) {
   return `\
<details><summary><a href="${wiki_url}#${desc.slug}">WGSL meeting minutes ${date}</a></summary>
${desc.text}
</details>`;
}

function extract_minutes() {
   const text = e_in.value;
   const tree = md_to_tree(text);

   const h1 = (() => {
      for (const x of tree.children) {
         if (x.title) return x;
      }
      throw tree.children;
   })();
   console.log('tree', tree);

   const date = find_date(h1.title);
   date.defined;
   console.assert(h1.title.startsWith('# '));
   let page_name = h1.title.slice(2);
   page_name = to_github_url_slug(page_name);

   const wiki_url = `https://github.com/gpuweb/gpuweb/wiki/${page_name}`;

   while (e_out.firstChild) {
      e_out.removeChild(e_out.firstChild);
   }

   function f(cur) {
      if (cur.h_level === undefined) return; // A string, not a section.
      if (cur.h_level != 3) {
         for (const child of cur.children) {
            f(child);
         }
         return;
      }
      const desc = section_desc(cur);
      //console.log(desc);

      const details = make_details(date, wiki_url, desc);
      e_out.appendChild(document.createElement('br'));
      const out = e_out.appendChild(document.createElement('div'));

      let e_section_title;
      if (desc.issue_url) {
         e_section_title = out.appendChild(document.createElement('a'));
         e_section_title.href = desc.issue_url;
      } else {
         e_section_title = out.appendChild(document.createElement('span'));
      }
      e_section_title.textContent = cur.title;

      out.appendChild(document.createElement('br'));
      const e_details = out.appendChild(document.createElement('pre'));
      e_details.style.border = '1px solid black';
      e_details.textContent = details;
   }
   f(tree);
}

e_extract.addEventListener('click', extract_minutes, false);
      </script>
   </body>
</html>
