<doctype html>
<html>
   <head>
      <meta charset='utf-8'>
   </head>
   <body>
      Markdown:
      <br>
      <textarea id='e_in' style='width: 100%; height: 50vh;'>
&lt;!-- Output copied to clipboard! --&gt;


# WGSL 2021-00-00 Minutes

### Example 1

* lorem

## H2


### [Example 2](example.com)

* ipsum

### Example [5](example.com/5) (stuff)

* dolor


## H2 Example [3](example.com/3)

* sit amet

</textarea>
      <br>Override URL: <input type=url id=e_link_url style='width: 50%'></input>
      <br>Override Title: <input type=text id=e_link_title style='width: 50%'></input>
      <br><button id='e_extract'>Extract</button>
      <hr>
      <div id='e_out'></div>
      <script>
'use strict';

function count_char_repeats(str, c) {
   let i = 0;
   while (str[i] == c) {
      i += 1;
   }
   return i;
}
{
   if (count_char_repeats('### hi', '#') != 3) throw 3;
}

function MdSection(title) {
   this.title = title;
   this.h_level = count_char_repeats(title || '', '#');
   this.children = [];

   this.add_child = child => {
      child.parent = this;
      this.children.push(child);
   };
}

function md_to_tree(text) {
   const lines = text.split('\n');
   const root = new MdSection(null);
   let cur_sec = root;
   while (lines.length) {
      const line = lines.shift();
      const h_level = count_char_repeats(line, '#');
      if (!h_level) {
         cur_sec.children.push(line);
         continue;
      }
      const new_sec = new MdSection(line);

      const parent_h_level = new_sec.h_level - 1;
      while (cur_sec.h_level > parent_h_level) {
         cur_sec = cur_sec.parent;
      }
      //while (cur_sec.h_level < parent_h_level) {
      //   const dummy = new MdSection('#'.repeat(cur_sec.h_level + 1));
      //   dummy.title = undefined;
      //   cur_sec.add_child(dummy);
      //   cur_sec = dummy;
      //}

      cur_sec.add_child(new_sec);
      cur_sec = new_sec;
   }
   return root;
}

function* range(n) {
   for (let i = 0; i < n; i++) {
      yield i;
   }
}

function trimPrefix(str, prefix) {
   if (str.startsWith(prefix)) {
      str = str.slice(prefix.length);
   }
   return str;
}
function withoutPrefix(str, prefix) {
   const ret = trimPrefix(str, prefix);
   if (ret == str) throw {str, prefix};
   return ret;
}

const RE_DATE = /\d\d\d\d-\d\d-\d\d/;
function find_date(str) {
   const match = str.match(RE_DATE) || [];
   return match;
}
if (find_date('# WGSL 2021-04-13 Minutes') != '2021-04-13') throw 'find_date';

function to_github_general_url_slug(text) {
   let parts = text.split(/ +/);
   parts = parts.map(s => {
      s = s.toLowerCase();
      s = [].filter.call(s, c => c.match(/[0-9A-Za-z-_()\/]/)); // Filter character set.
      s = s.join('');
      return s;
   });
   return parts.join('-');
}
function to_github_page_slug(text) {
   let ret = to_github_general_url_slug(text);
   ret = ret.replaceAll(/[()\/]/g, '-');
   return ret;
}
function to_github_anchor_slug(text) {
   let ret = to_github_general_url_slug(text);
   ret = ret.replaceAll(/[()\/]/g, '');
   return ret;
}

{
   const title = '[wgsl] Proposal: Remove pointer out parameters from modf, frexp 路 Issue #1480 路 gpuweb/gpuweb';
   const expected = 'wgsl-proposal-remove-pointer-out-parameters-from-modf-frexp--issue-1480--gpuwebgpuweb';
   const was = to_github_anchor_slug(title);
   if (was != expected) throw was;
}
{
   const title = 'Triage the issues without milestones (timebox 15m).';
   const expected = 'triage-the-issues-without-milestones-timebox-15m';
   const was = to_github_anchor_slug(title);
   if (was != expected) throw was;
}
{
   const title    = 'GPU Web meeting 2022-08-02/03 APAC-timed';
   const expected = 'gpu-web-meeting-2022-08-02-03-apac-timed';
   const was = to_github_page_slug(title);
   if (was != expected) throw was;
}

const RE_URL = /\[(.*)\]\((.*?)\)/g;

function section_desc(node) {
   let issue_url;
   let slug;
   if (node.title) {
      if (!node.title.startsWith('#')) throw node.title;
      const section_title = node.title.replace(/#+ /, '');
      const found = Array.from(section_title.matchAll(RE_URL));
      issue_url = (found[0] || [])[2];
      const title_text = section_title.replaceAll(RE_URL, '$1');
      slug = to_github_anchor_slug(title_text);
   }

   // -
   // A section's `children` contain, zero or more string children, followed
   // by zero or more subsection children.

   let content = [];
   let subsections = [];
   for (const child of node.children) {
      if (child.h_level) { // section
         subsections.push(child);
      } else {
         if (subsections.length) throw node;
         content.push(child);
      }
   }
   content = content.join('\n');
   content = content.replace(/^\n+/, '');
   content = content.replace(/\n+$/, '');

   // -

   const ret = {
      issue_url,
      slug,
      content,
      subsections,
   };
   if (!ret.content) delete ret.content;
   if (!ret.subsections.length) delete ret.subsections;
   return ret;
}

// -
// Tests

{
   const content = `\


*   DM: Do we want to spend innovation budget on anonymous structs here?
*   BC: Previously there were concerns about having to have a named struct to return here, but now with type inference, we could return anonymous structs here. Not necessarily proposing userland anonymous structs, and if we decided to name them in the future, we could name them.
*   DM: Some complexity, new types for these builtins.`;
   const h3_section = {
      title: '### [[wgsl] Proposal: Remove pointer out parameters from modf, frexp 路 Issue #1480 路 gpuweb/gpuweb](https://github.com/gpuweb/gpuweb/issues/1480)',
      h_level: 3,
      children: content.split('\n'),
   };
   const expected = {
      issue_url: 'https://github.com/gpuweb/gpuweb/issues/1480',
      slug: 'wgsl-proposal-remove-pointer-out-parameters-from-modf-frexp--issue-1480--gpuwebgpuweb',
      content: content.trim(),
   };
   const was = section_desc(h3_section);
   if (JSON.stringify(expected) != JSON.stringify(was)) throw {was, expected};
}

// -

function make_details(desc) {
   return `\
<details><summary><a href="${e_link_url.value}#${desc.slug}">${e_link_title.value}</a></summary>

${desc.content}

</details>`;
}

function extract_minutes() {
   const text = e_in.value;
   const tree = md_to_tree(text);
   console.log('tree', tree);

   const first_titled = (() => {
      for (const x of tree.children) {
         if (x.title) return x;
      }
      throw tree.children;
   })();

   console.assert(first_titled.title.startsWith('# '));
   const page_title = first_titled.title.slice(2);
   const page_slug = to_github_page_slug(page_title);

   const wiki_url = `https://github.com/gpuweb/gpuweb/wiki/${page_slug}`;

   if (!e_link_url.value) {
      e_link_url.value = wiki_url;
   }
   if (!e_link_title.value) {
      e_link_title.value = page_title;
   }

   while (e_out.firstChild) {
      e_out.removeChild(e_out.firstChild);
   }

   function per_section_node(cur) {
      if (cur.h_level === undefined) return; // A string, not a section: Don't recurse.

      const section = section_desc(cur);
      console.log(section);

      if (section.content) {
         const details = make_details(section);
         e_out.appendChild(document.createElement('br'));
         const out = e_out.appendChild(document.createElement('div'));

         let e_section_title;
         if (section.issue_url) {
            e_section_title = out.appendChild(document.createElement('a'));
            e_section_title.href = section.issue_url;
         } else {
            e_section_title = out.appendChild(document.createElement('span'));
         }
         e_section_title.textContent = cur.title;

         out.appendChild(document.createElement('br'));
         const e_details = out.appendChild(document.createElement('pre'));
         e_details.style.border = '1px solid black';
         e_details.textContent = details;
      }

      // -

      if (section.subsections) {
         for (const sub of section.subsections) {
            per_section_node(sub);
         }
      }
   }
   per_section_node(tree);
}

e_extract.addEventListener('click', extract_minutes, false);
      </script>
   </body>
</html>
